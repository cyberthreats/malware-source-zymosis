; ============================================================================
;	реализация таблицы импорта
; 	last change :: 29.10.2007
; ============================================================================



; ============================================================================================	
;  in		:  eax - хэш искомой в kernel32 функции
;  out		:  eax - адрес искомой функции
;  actions	:  вытаскивает адрес функции из kernel32, хэш имени которой передан через eax
;  changes	:  eax
get_ke32_function_by_hash proc
	LOCAL hash:DWORD
	LOCAL kernel_base:DWORD
	
	LOCAL result:DWORD
	
	LOCAL addr_of_names:DWORD
	LOCAL addr_of_name_ordinals:DWORD
	LOCAL addr_of_func:DWORD
	LOCAL number_of_names:DWORD
	LOCAL n_base:DWORD

		pushad
		mov		hash, eax
		
		call	get_kernel32_base		
		mov		kernel_base, eax
		
		mov		esi, eax							; esi = eax = kernel32 base
		assume 	esi:ptr IMAGE_DOS_HEADER
		add 	esi, [esi].e_lfanew 				; esi = ptr to PE header
		assume 	esi:ptr IMAGE_NT_HEADERS
		lea 	esi, [esi].OptionalHeader			; esi = ptr to Optional header
		assume 	esi:ptr IMAGE_OPTIONAL_HEADER
		lea 	esi, [esi].DataDirectory
		mov 	esi, dword ptr [esi]
		add 	esi, eax 							; esi = ptr to IMAGE_EXPORT_DIRECTORY
		assume 	esi:ptr IMAGE_EXPORT_DIRECTORY	
		
		; сохраняем необходимые данные в локальные переменные
		mov 	edx, [esi].AddressOfNames
		add 	edx, eax
		mov		addr_of_names, edx
		; ;
		mov		edx, [esi].AddressOfNameOrdinals
		add		edx, eax
		mov		addr_of_name_ordinals, edx
		; ;
		mov		edx, [esi].AddressOfFunctions
		add		edx, eax
		mov		addr_of_func, edx
		; ;
		mov		edx, [esi].NumberOfNames
		mov		number_of_names, edx
		; ;
		mov		edx, [esi].nBase
		mov		n_base, edx
		assume 	esi:NOTHING
		
		; начинаем поиск
		mov		edx, hash					; edx - хеш вызываемой функции
		mov		edi, addr_of_names			; edi - указатель на массив имён в экспорте dll'ки	
		xor		ecx, ecx
		
__get_ke32_func_next_name:
		mov		esi, dword ptr [edi]				
		add		esi, kernel_base			; esi - указатель на имя функции
		call	calc_hash					; считаем хэш строки, на которую указывает esi
		cmp		eax, edx					; сравниваем результат с искомым хешем
		je		__get_ke32_func_name_found
		cmp		ecx, number_of_names
		je		__get_ke32_func_end
		add		edi, 4						; если не совпали - переходим к следующему имени в массиве
		inc		ecx
		jmp		__get_ke32_func_next_name
		
__get_ke32_func_name_found:		
		xor		edx, edx
		mov		esi, addr_of_name_ordinals		; esi = AddressOfNameOrdinals[0]
		mov 	 dx, word ptr [esi][ecx * 2] 		; edx  = function ordinal
	
		sub 	edx, n_base 						; вычитаем начальный ординал
		inc 	edx									; т.к. начальный ординал начинается с 1
	
		mov 	esi, addr_of_func
	
		mov 	edi, dword ptr [esi][edx * 4]
		add 	edi, kernel_base					; в eax - адрес функции 
		mov		result, edi
		
__get_ke32_func_end:		
		popad
		mov		eax, result
		ret
get_ke32_function_by_hash endp	
; ============================================================================================	




COMMENT "
; ============================================================================================	
;  in		:  eax - хэш искомой в ntdll функции
;  out		:  eax - адрес искомой функции
;  actions	:  вытаскивает адрес ntdll-овской функции, хэш имени которой передач через eax
;  changes	:  eax
get_function_by_hash proc	dll_name:DWORD
	LOCAL hash:DWORD
	LOCAL dll_base:DWORD
	
	LOCAL result:DWORD
	
	LOCAL addr_of_names:DWORD
	LOCAL addr_of_name_ordinals:DWORD
	LOCAL addr_of_func:DWORD
	LOCAL number_of_names:DWORD
	LOCAL n_base:DWORD

		pushad
		mov			hash, eax
		mov			result, 0
		
		push		dll_name
		ke32_call	GetModuleHandleA		; попытаться найти смещение дллки
		test		eax, eax
		jnz			__get_func_dll_loaded	; если она уже загружена - то перейти к поиску
		push		dll_name
		ke32_call	LoadLibraryA			; если не загружена - то попытаться загрузить
		test		eax, eax
		jz			__get_func_end
		
__get_func_dll_loaded:
		mov			dll_base, eax
		
		mov			esi, eax							; esi = eax = ntdll base
		assume 		esi:ptr IMAGE_DOS_HEADER
		add 		esi, [esi].e_lfanew 				; esi = ptr to PE header
		assume 		esi:ptr IMAGE_NT_HEADERS
		lea 		esi, [esi].OptionalHeader			; esi = ptr to Optional header
		assume 		esi:ptr IMAGE_OPTIONAL_HEADER
		lea 		esi, [esi].DataDirectory
		mov 		esi, dword ptr [esi]
		add 		esi, eax 							; esi = ptr to IMAGE_EXPORT_DIRECTORY
		assume 		esi:ptr IMAGE_EXPORT_DIRECTORY	
		
		; сохраняем необходимые данные в локальные переменные
		mov 	edx, [esi].AddressOfNames
		add 	edx, eax
		mov		addr_of_names, edx
		; ;
		mov		edx, [esi].AddressOfNameOrdinals
		add		edx, eax
		mov		addr_of_name_ordinals, edx
		; ;
		mov		edx, [esi].AddressOfFunctions
		add		edx, eax
		mov		addr_of_func, edx
		; ;
		mov		edx, [esi].NumberOfNames
		mov		number_of_names, edx
		; ;
		mov		edx, [esi].nBase
		mov		n_base, edx
		assume 	esi:NOTHING
		
		; начинаем поиск
		mov		edx, hash					; edx - хеш вызываемой функции
		mov		edi, addr_of_names			; edi - указатель на массив имён в экспорте dll'ки	
		xor		ecx, ecx
		
__get_func_next_name:
		mov		esi, dword ptr [edi]				
		add		esi, dll_base				; esi - указатель на имя функции
		call	calc_hash					; считаем хэш строки, на которую указывает esi
		cmp		eax, edx					; сравниваем результат с искомым хешем
		je		__get_func_name_found
		cmp		ecx, number_of_names
		je		__get_func_end
		add		edi, 4						; если не совпали - переходим к следующему имени в массиве
		inc		ecx
		jmp		__get_func_next_name
		
__get_func_name_found:		
		xor		edx, edx
		mov		esi, addr_of_name_ordinals			; esi = AddressOfNameOrdinals[0]
		mov 	 dx, word ptr [esi][ecx * 2] 		; edx  = function ordinal
	
		sub 	edx, n_base 						; вычитаем начальный ординал
		inc 	edx									; т.к. начальный ординал начинается с 1
	
		mov 	esi, addr_of_func
	
		mov 	edi, dword ptr [esi][edx * 4]
		add 	edi, dll_base						; в edi - адрес функции 
		mov		result, edi
		
__get_func_end:
		popad
		mov		eax, result
		ret
get_function_by_hash endp
; ============================================================================================	
"




; ============================================================================================	
;  in		:  esi - указатель на ASCIIZ-строку 
;  out		:  eax - хэш строки, на которую указывал esi
;  actions	:  вычисляет хэш строки
;  changes	:  esi - указатель на завершающий ноль строки
calc_hash	proc
		mov		eax, hash32factor
__calc_hash:            
		rol		eax, 7
		xor		al, byte ptr [esi]
		inc		esi
		cmp		byte ptr [esi], 0
		jne		__calc_hash
		
		ret
calc_hash	endp
; ============================================================================================	





; ============================================================================================	
;  in		:  nothing
;  out		:  eax - kernel32.dll base
;  actions	:  вычисляет смещение кернела в памяти процесса
;  changes	:  eax
get_kernel32_base proc
		assume		fs:NOTHING
		mov     	eax, fs:[30h]
		test    	eax, eax
		js      	short __get_kernel32_base_w9x
		
	__get_kernel32_base_wNTx:
		push    	esi
		cld
		mov     	eax, [eax + 0Ch]
		mov     	esi, [eax + 1Ch]
		lodsd
		mov     	eax, [eax + 8]
		pop     	esi
		jmp     	__get_kernel32_base_end
		
	__get_kernel32_base_w9x:
		mov     	eax, [eax + 34h]
		mov     	eax, [eax + 0B8h]
		
	__get_kernel32_base_end:
		ret
get_kernel32_base endp	
; ============================================================================================	



; ============================================================================================	
;  		имена библиотек
IF	NTDLL
		ntdll			DB		"ntdll", 0
ENDIF

IF	USER32		
		user32			DB		"user32", 0
ENDIF
; ============================================================================================	



; ============================================================================================	
		align			4
;  		таблица соответствия хэшей и имён функций
;		
		FindFirstFileA		DD		086A128C7h
		FindNextFileA		DD		020F42ECEh
		FindClose		DD		00DD40351h
		CreateFileA		DD		0189CECB3h
		GetFileAttributesA		DD		07C1BA77Fh
		SetFileAttributesA		DD		0761BA77Fh
		GetFileTime		DD		0BE73DDD6h
		SetFileTime		DD		0BE73D8D6h
		GetFileSize		DD		0BE93D656h
		CloseHandle		DD		0625AAD72h
		SetFilePointer		DD		05BAAECB9h
		SetEndOfFile		DD		01F034EE9h
		WriteFile		DD		079A39053h
		ReadFile		DD		06892D9E8h
		CreateThread		DD		05DB64978h
		SetThreadPriority		DD		02C50BFD4h
		WaitForSingleObject		DD		0625310EEh
		ExitProcess		DD		085F436BEh
		GetLogicalDrives		DD		0E9139B8Fh
		GetDriveTypeA		DD		03EFA90D7h
		GetVolumeInformationA		DD		07EEBB753h
		;GetProcessHeap		DD		0DC627FD7h
		;GetModuleHandleA		DD		027AD8A5Ah
		;LoadLibraryA		DD		0FAA253AEh
		;RtlAllocateHeap		DD		0E1108CF1h
		;RtlFreeHeap		DD		025F0B2C3h
		Sleep		DD		0545D6BF2h
IF	STAT		
		_wsprintfA		DD		09CA6B147h
ENDIF
IF DEBUG
		OutputDebugStringA		DD		0EB07AC1Ch
ENDIF

; ============================================================================================
